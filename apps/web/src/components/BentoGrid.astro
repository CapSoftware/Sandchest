---
const features = [
  {
    title: "Sub-100ms forking",
    description: "Fork a running sandbox — memory, disk, everything — in under 100ms.",
    animationId: "fork-anim",
  },
  {
    title: "VM-grade isolation",
    description: "Every sandbox is a real Firecracker microVM. Full hardware-level isolation.",
    animationId: "shield-anim",
  },
  {
    title: "TypeScript SDK",
    description: "Create, exec, fork, and manage sandboxes with a few lines of code.",
    animationId: "sdk-anim",
  },
  {
    title: "Session replay",
    description: "Every session is fully replayable. Logs, file changes, and terminal output.",
    animationId: "replay-anim",
  },
  {
    title: "MCP server",
    description: "First-class MCP support for Claude Code and other AI tools.",
    animationId: "mcp-anim",
  },
  {
    title: "CLI",
    description: "Create, exec, fork, and SSH into sandboxes from your terminal.",
    animationId: "cli-anim",
  },
];
---

<section id="features" class="section">
  <div class="section-header">
    <h3 class="section-title">What is Sandchest?</h3>
    <p class="text-text">
      A sandbox platform for AI agent code execution. Every sandbox is a Firecracker microVM with VM-grade isolation, sub-second fork capability, and a permanent session replay URL.
    </p>
  </div>

  <div class="bento-grid">
    {features.map((feature, i) => (
      <div class="bento-cell" style={`--delay: ${i * 80}ms;`}>
        <div class="bento-animation" id={feature.animationId}></div>
        <div class="bento-content">
          <h4 class="bento-title">{feature.title}</h4>
          <p class="bento-desc">{feature.description}</p>
        </div>
      </div>
    ))}
  </div>
</section>

<style>
  .bento-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 1px;
    border-radius: 8px;
    overflow: hidden;
    background: var(--color-border-weak);
  }

  @media (max-width: 60rem) {
    .bento-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (max-width: 36rem) {
    .bento-grid {
      grid-template-columns: 1fr;
    }
  }

  .bento-cell {
    background: var(--color-surface);
    padding: 32px;
    display: flex;
    flex-direction: column;
    gap: 24px;
    transition: background 0.3s ease;
  }

  @media (max-width: 36rem) {
    .bento-cell {
      padding: 20px;
      gap: 16px;
    }

    .bento-animation {
      height: 100px;
    }
  }

  .bento-cell:hover {
    background: var(--color-surface-hover);
  }

  .bento-animation {
    height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  .bento-animation canvas {
    max-width: 100%;
    height: auto;
  }

  .bento-title {
    font-size: 15px;
    font-weight: 600;
    color: var(--color-text-strong);
    margin-bottom: 6px;
  }

  .bento-desc {
    font-size: 13px;
    color: var(--color-text-weak);
    line-height: 170%;
  }
</style>

<script>
  // ── Fork animation (canvas-based for smooth forking visual) ──
  function initForkAnimation() {
    const container = document.getElementById('fork-anim');
    if (!container) return;
    container.innerHTML = '';

    const canvas = document.createElement('canvas');
    const w = 200, h = 120;
    canvas.width = w * 2; canvas.height = h * 2;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    container.appendChild(canvas);
    const ctx = canvas.getContext('2d')!;
    ctx.scale(2, 2);

    const accent = getComputedStyle(document.documentElement).getPropertyValue('--color-accent').trim();
    const weak = getComputedStyle(document.documentElement).getPropertyValue('--color-text-weak').trim();

    let t = 0;
    function draw() {
      ctx.clearRect(0, 0, w, h);
      const progress = (Math.sin(t * 0.02) + 1) / 2; // 0→1→0 loop

      ctx.strokeStyle = accent;
      ctx.lineWidth = 1.5;
      ctx.lineCap = 'round';

      // Main trunk
      const trunkH = 35;
      const trunkStart = h - 15;
      const centerX = w / 2;

      ctx.beginPath();
      ctx.moveTo(centerX, trunkStart);
      ctx.lineTo(centerX, trunkStart - trunkH);
      ctx.stroke();

      // Fork point dot
      ctx.fillStyle = accent;
      ctx.beginPath();
      ctx.arc(centerX, trunkStart - trunkH, 3, 0, Math.PI * 2);
      ctx.fill();

      // Left branch
      const branchLen = 30 + progress * 20;
      const branchAngle = 0.5 + progress * 0.3;

      ctx.strokeStyle = accent;
      ctx.beginPath();
      ctx.moveTo(centerX, trunkStart - trunkH);
      ctx.lineTo(
        centerX - Math.sin(branchAngle) * branchLen,
        trunkStart - trunkH - Math.cos(branchAngle) * branchLen
      );
      ctx.stroke();

      // Right branch
      ctx.beginPath();
      ctx.moveTo(centerX, trunkStart - trunkH);
      ctx.lineTo(
        centerX + Math.sin(branchAngle) * branchLen,
        trunkStart - trunkH - Math.cos(branchAngle) * branchLen
      );
      ctx.stroke();

      // Branch end dots
      const dotSize = 2 + progress * 1.5;

      ctx.fillStyle = accent;
      ctx.beginPath();
      ctx.arc(
        centerX - Math.sin(branchAngle) * branchLen,
        trunkStart - trunkH - Math.cos(branchAngle) * branchLen,
        dotSize, 0, Math.PI * 2
      );
      ctx.fill();

      ctx.beginPath();
      ctx.arc(
        centerX + Math.sin(branchAngle) * branchLen,
        trunkStart - trunkH - Math.cos(branchAngle) * branchLen,
        dotSize, 0, Math.PI * 2
      );
      ctx.fill();

      // Subtle particle rising from fork point
      const particleY = (trunkStart - trunkH) - (progress * 30);
      ctx.globalAlpha = 1 - progress;
      ctx.fillStyle = accent;
      ctx.beginPath();
      ctx.arc(centerX, particleY, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      t++;
      requestAnimationFrame(draw);
    }
    draw();
  }

  // ── Shield animation (pulsing concentric shields) ──
  function initShieldAnimation() {
    const container = document.getElementById('shield-anim');
    if (!container) return;
    container.innerHTML = '';

    const canvas = document.createElement('canvas');
    const w = 200, h = 120;
    canvas.width = w * 2; canvas.height = h * 2;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    container.appendChild(canvas);
    const ctx = canvas.getContext('2d')!;
    ctx.scale(2, 2);

    const accent = getComputedStyle(document.documentElement).getPropertyValue('--color-accent').trim();
    const border = getComputedStyle(document.documentElement).getPropertyValue('--color-border').trim();

    let t = 0;
    function draw() {
      ctx.clearRect(0, 0, w, h);
      const cx = w / 2, cy = h / 2;

      // Draw concentric rounded rects (shield layers)
      for (let i = 0; i < 3; i++) {
        const phase = (t * 0.015 + i * 0.8) % (Math.PI * 2);
        const pulse = Math.sin(phase) * 0.3 + 0.7;
        const size = 16 + i * 14;
        const alpha = (0.8 - i * 0.25) * pulse;

        ctx.strokeStyle = i === 0 ? accent : border;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = i === 0 ? 1.5 : 1;

        // Shield shape
        ctx.beginPath();
        const sw = size;
        const sh = size * 1.15;
        ctx.moveTo(cx, cy - sh);
        ctx.bezierCurveTo(cx + sw, cy - sh * 0.6, cx + sw, cy + sh * 0.2, cx, cy + sh);
        ctx.bezierCurveTo(cx - sw, cy + sh * 0.2, cx - sw, cy - sh * 0.6, cx, cy - sh);
        ctx.stroke();
      }

      // Center dot
      ctx.globalAlpha = 0.6 + Math.sin(t * 0.03) * 0.4;
      ctx.fillStyle = accent;
      ctx.beginPath();
      ctx.arc(cx, cy - 2, 2.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 1;
      t++;
      requestAnimationFrame(draw);
    }
    draw();
  }

  // ── SDK animation (floating code symbols) ──
  function initSdkAnimation() {
    const container = document.getElementById('sdk-anim');
    if (!container) return;
    container.innerHTML = '';

    const canvas = document.createElement('canvas');
    const w = 200, h = 120;
    canvas.width = w * 2; canvas.height = h * 2;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    container.appendChild(canvas);
    const ctx = canvas.getContext('2d')!;
    ctx.scale(2, 2);

    const accent = getComputedStyle(document.documentElement).getPropertyValue('--color-accent').trim();
    const weak = getComputedStyle(document.documentElement).getPropertyValue('--color-text-weak').trim();

    const symbols = ['{ }', '( )', '=>', '[ ]', 'fn', '< />'];
    const particles = symbols.map((s, i) => ({
      text: s,
      x: 30 + (i % 3) * 60 + Math.random() * 20,
      y: 25 + Math.floor(i / 3) * 50 + Math.random() * 10,
      baseX: 30 + (i % 3) * 60 + Math.random() * 20,
      baseY: 25 + Math.floor(i / 3) * 50 + Math.random() * 10,
      phase: Math.random() * Math.PI * 2,
      speed: 0.008 + Math.random() * 0.008,
    }));

    let t = 0;
    function draw() {
      ctx.clearRect(0, 0, w, h);
      ctx.font = '13px "Geist Mono", monospace';
      ctx.textAlign = 'center';

      particles.forEach((p, i) => {
        p.x = p.baseX + Math.sin(t * p.speed + p.phase) * 8;
        p.y = p.baseY + Math.cos(t * p.speed * 1.3 + p.phase) * 6;

        const alpha = 0.3 + Math.sin(t * 0.02 + i) * 0.2 + 0.2;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = i % 2 === 0 ? accent : weak;
        ctx.fillText(p.text, p.x, p.y);
      });

      ctx.globalAlpha = 1;
      t++;
      requestAnimationFrame(draw);
    }
    draw();
  }

  // ── Replay animation (timeline with scrubbing playhead) ──
  function initReplayAnimation() {
    const container = document.getElementById('replay-anim');
    if (!container) return;
    container.innerHTML = '';

    const canvas = document.createElement('canvas');
    const w = 200, h = 120;
    canvas.width = w * 2; canvas.height = h * 2;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    container.appendChild(canvas);
    const ctx = canvas.getContext('2d')!;
    ctx.scale(2, 2);

    const accent = getComputedStyle(document.documentElement).getPropertyValue('--color-accent').trim();
    const border = getComputedStyle(document.documentElement).getPropertyValue('--color-border').trim();
    const weak = getComputedStyle(document.documentElement).getPropertyValue('--color-text-weak').trim();

    const events = [25, 55, 80, 105, 130, 155, 170];

    let t = 0;
    function draw() {
      ctx.clearRect(0, 0, w, h);

      const lineY = h / 2 + 10;
      const lineStart = 20;
      const lineEnd = w - 20;

      // Timeline track
      ctx.strokeStyle = border;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(lineStart, lineY);
      ctx.lineTo(lineEnd, lineY);
      ctx.stroke();

      // Event markers
      events.forEach(x => {
        ctx.fillStyle = border;
        ctx.beginPath();
        ctx.arc(x, lineY, 2, 0, Math.PI * 2);
        ctx.fill();
      });

      // Playhead position (scrubs back and forth)
      const progress = (Math.sin(t * 0.012) + 1) / 2;
      const playheadX = lineStart + progress * (lineEnd - lineStart);

      // Filled portion
      ctx.strokeStyle = accent;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(lineStart, lineY);
      ctx.lineTo(playheadX, lineY);
      ctx.stroke();

      // Highlight passed events
      events.forEach(x => {
        if (x <= playheadX) {
          ctx.fillStyle = accent;
          ctx.beginPath();
          ctx.arc(x, lineY, 2.5, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      // Playhead
      ctx.fillStyle = accent;
      ctx.beginPath();
      ctx.arc(playheadX, lineY, 5, 0, Math.PI * 2);
      ctx.fill();

      // Playhead glow
      ctx.globalAlpha = 0.15;
      ctx.beginPath();
      ctx.arc(playheadX, lineY, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // Mini terminal lines above (revealed by playhead)
      const termY = lineY - 35;
      for (let i = 0; i < 4; i++) {
        const lx = 35;
        const ly = termY + i * 10;
        const lw = 30 + (i * 17) % 40;
        const lineProgress = (playheadX - lineStart) / (lineEnd - lineStart);
        const lineAlpha = Math.max(0, Math.min(1, (lineProgress - i * 0.15) * 3));

        ctx.globalAlpha = lineAlpha * 0.5;
        ctx.fillStyle = weak;
        ctx.fillRect(lx, ly, lw, 2);
      }

      ctx.globalAlpha = 1;
      t++;
      requestAnimationFrame(draw);
    }
    draw();
  }

  // ── MCP animation (central hub with orbiting connections) ──
  function initMcpAnimation() {
    const container = document.getElementById('mcp-anim');
    if (!container) return;
    container.innerHTML = '';

    const canvas = document.createElement('canvas');
    const w = 200, h = 120;
    canvas.width = w * 2; canvas.height = h * 2;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    container.appendChild(canvas);
    const ctx = canvas.getContext('2d')!;
    ctx.scale(2, 2);

    const accent = getComputedStyle(document.documentElement).getPropertyValue('--color-accent').trim();
    const border = getComputedStyle(document.documentElement).getPropertyValue('--color-border').trim();
    const weak = getComputedStyle(document.documentElement).getPropertyValue('--color-text-weak').trim();

    const nodes = [
      { angle: 0, radius: 38, size: 4 },
      { angle: Math.PI * 0.6, radius: 35, size: 3.5 },
      { angle: Math.PI * 1.2, radius: 40, size: 3 },
      { angle: Math.PI * 1.7, radius: 32, size: 3.5 },
    ];

    let t = 0;
    function draw() {
      ctx.clearRect(0, 0, w, h);
      const cx = w / 2, cy = h / 2;

      // Central node
      ctx.fillStyle = accent;
      ctx.beginPath();
      ctx.arc(cx, cy, 5, 0, Math.PI * 2);
      ctx.fill();

      // Central glow
      ctx.globalAlpha = 0.08 + Math.sin(t * 0.03) * 0.05;
      ctx.beginPath();
      ctx.arc(cx, cy, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // Orbiting nodes + connections
      nodes.forEach((node, i) => {
        const a = node.angle + t * 0.008;
        const nx = cx + Math.cos(a) * node.radius;
        const ny = cy + Math.sin(a) * node.radius;

        // Connection line
        ctx.strokeStyle = border;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(nx, ny);
        ctx.stroke();

        // Data packet traveling along the line
        const packetProgress = (Math.sin(t * 0.025 + i * 1.5) + 1) / 2;
        const px = cx + (nx - cx) * packetProgress;
        const py = cy + (ny - cy) * packetProgress;
        ctx.fillStyle = accent;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(px, py, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Outer node
        ctx.fillStyle = weak;
        ctx.beginPath();
        ctx.arc(nx, ny, node.size, 0, Math.PI * 2);
        ctx.fill();
      });

      t++;
      requestAnimationFrame(draw);
    }
    draw();
  }

  // ── CLI animation (terminal with typing command) ──
  function initCliAnimation() {
    const container = document.getElementById('cli-anim');
    if (!container) return;
    container.innerHTML = '';

    const canvas = document.createElement('canvas');
    const w = 200, h = 120;
    canvas.width = w * 2; canvas.height = h * 2;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    container.appendChild(canvas);
    const ctx = canvas.getContext('2d')!;
    ctx.scale(2, 2);

    const accent = getComputedStyle(document.documentElement).getPropertyValue('--color-accent').trim();
    const weak = getComputedStyle(document.documentElement).getPropertyValue('--color-text-weak').trim();
    const textStrong = getComputedStyle(document.documentElement).getPropertyValue('--color-text-strong').trim();

    const commands = [
      '$ sandchest create',
      '$ sandchest exec "npm test"',
      '$ sandchest fork sb_3kx',
    ];

    let t = 0;
    function draw() {
      ctx.clearRect(0, 0, w, h);
      ctx.font = '11px "Geist Mono", monospace';
      ctx.textAlign = 'left';

      const cycleLen = 200; // frames per command
      const cmdIndex = Math.floor(t / cycleLen) % commands.length;
      const cmdProgress = (t % cycleLen) / cycleLen;

      // Previous completed commands (faded)
      for (let i = 0; i < cmdIndex && i < 2; i++) {
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = weak;
        ctx.fillText(commands[i], 20, 35 + i * 22);
      }

      // Current command being typed
      const cmd = commands[cmdIndex];
      const visibleChars = Math.min(
        cmd.length,
        Math.floor(cmdProgress * cmd.length * 2)
      );
      const typedText = cmd.substring(0, visibleChars);
      const y = 35 + Math.min(cmdIndex, 2) * 22;

      ctx.globalAlpha = 1;

      // Prompt ($) in accent
      if (typedText.length > 0) {
        ctx.fillStyle = accent;
        ctx.fillText('$', 20, y);
        ctx.fillStyle = textStrong;
        ctx.fillText(typedText.substring(1), 20 + ctx.measureText('$').width, y);
      }

      // Blinking cursor
      const cursorOn = Math.sin(t * 0.08) > 0;
      if (cursorOn && cmdProgress < 0.7) {
        const cursorX = 20 + ctx.measureText(typedText).width + 2;
        ctx.fillStyle = accent;
        ctx.fillRect(cursorX, y - 9, 6, 12);
      }

      // Output line after command finishes typing
      if (cmdProgress > 0.6) {
        const outputAlpha = Math.min(1, (cmdProgress - 0.6) * 5);
        ctx.globalAlpha = outputAlpha * 0.4;
        ctx.fillStyle = weak;
        const outputs = ['sandbox sb_3kx created', 'exit code: 0', 'forked → sb_7mq'];
        ctx.fillText(outputs[cmdIndex], 26, y + 18);
      }

      ctx.globalAlpha = 1;
      t++;
      requestAnimationFrame(draw);
    }
    draw();
  }

  // Initialize all animations
  initForkAnimation();
  initShieldAnimation();
  initSdkAnimation();
  initReplayAnimation();
  initMcpAnimation();
  initCliAnimation();
</script>
