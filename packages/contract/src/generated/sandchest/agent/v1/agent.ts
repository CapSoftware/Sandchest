// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: sandchest/agent/v1/agent.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty } from "../../../google/protobuf/empty.js";

export const protobufPackage = "sandchest.agent.v1";

export interface HealthResponse {
  ready: boolean;
  version: string;
}

export interface ExecRequest {
  cmd: string[];
  shellCmd: string;
  cwd: string;
  env: { [key: string]: string };
  timeoutSeconds: number;
}

export interface ExecRequest_EnvEntry {
  key: string;
  value: string;
}

export interface ExecEvent {
  seq: number;
  stdout?: Buffer | undefined;
  stderr?: Buffer | undefined;
  exit?: ExitEvent | undefined;
}

export interface ExitEvent {
  exitCode: number;
  cpuMs: number;
  peakMemoryBytes: number;
  durationMs: number;
}

export interface CreateSessionRequest {
  shell: string;
  env: { [key: string]: string };
}

export interface CreateSessionRequest_EnvEntry {
  key: string;
  value: string;
}

export interface SessionResponse {
  sessionId: string;
}

export interface SessionExecRequest {
  sessionId: string;
  cmd: string;
  timeoutSeconds: number;
}

export interface SessionInputRequest {
  sessionId: string;
  data: Buffer;
}

export interface DestroySessionRequest {
  sessionId: string;
}

export interface FileChunk {
  path: string;
  data: Buffer;
  offset: number;
  done: boolean;
}

export interface PutFileResponse {
  bytesWritten: number;
}

export interface GetFileRequest {
  path: string;
}

export interface ListFilesRequest {
  path: string;
}

export interface ListFilesResponse {
  files: FileInfo[];
}

export interface FileInfo {
  path: string;
  size: number;
  isDir: boolean;
  modifiedAt: number;
}

function createBaseHealthResponse(): HealthResponse {
  return { ready: false, version: "" };
}

export const HealthResponse: MessageFns<HealthResponse> = {
  encode(message: HealthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ready !== false) {
      writer.uint32(8).bool(message.ready);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ready = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthResponse {
    return {
      ready: isSet(object.ready) ? globalThis.Boolean(object.ready) : false,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: HealthResponse): unknown {
    const obj: any = {};
    if (message.ready !== false) {
      obj.ready = message.ready;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<HealthResponse>): HealthResponse {
    return HealthResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthResponse>): HealthResponse {
    const message = createBaseHealthResponse();
    message.ready = object.ready ?? false;
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseExecRequest(): ExecRequest {
  return { cmd: [], shellCmd: "", cwd: "", env: {}, timeoutSeconds: 0 };
}

export const ExecRequest: MessageFns<ExecRequest> = {
  encode(message: ExecRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cmd) {
      writer.uint32(10).string(v!);
    }
    if (message.shellCmd !== "") {
      writer.uint32(18).string(message.shellCmd);
    }
    if (message.cwd !== "") {
      writer.uint32(26).string(message.cwd);
    }
    globalThis.Object.entries(message.env).forEach(([key, value]: [string, string]) => {
      ExecRequest_EnvEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.timeoutSeconds !== 0) {
      writer.uint32(40).uint32(message.timeoutSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cmd.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shellCmd = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cwd = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ExecRequest_EnvEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.env[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timeoutSeconds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecRequest {
    return {
      cmd: globalThis.Array.isArray(object?.cmd) ? object.cmd.map((e: any) => globalThis.String(e)) : [],
      shellCmd: isSet(object.shellCmd)
        ? globalThis.String(object.shellCmd)
        : isSet(object.shell_cmd)
        ? globalThis.String(object.shell_cmd)
        : "",
      cwd: isSet(object.cwd) ? globalThis.String(object.cwd) : "",
      env: isObject(object.env)
        ? (globalThis.Object.entries(object.env) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      timeoutSeconds: isSet(object.timeoutSeconds)
        ? globalThis.Number(object.timeoutSeconds)
        : isSet(object.timeout_seconds)
        ? globalThis.Number(object.timeout_seconds)
        : 0,
    };
  },

  toJSON(message: ExecRequest): unknown {
    const obj: any = {};
    if (message.cmd?.length) {
      obj.cmd = message.cmd;
    }
    if (message.shellCmd !== "") {
      obj.shellCmd = message.shellCmd;
    }
    if (message.cwd !== "") {
      obj.cwd = message.cwd;
    }
    if (message.env) {
      const entries = globalThis.Object.entries(message.env) as [string, string][];
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecRequest>): ExecRequest {
    return ExecRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecRequest>): ExecRequest {
    const message = createBaseExecRequest();
    message.cmd = object.cmd?.map((e) => e) || [];
    message.shellCmd = object.shellCmd ?? "";
    message.cwd = object.cwd ?? "";
    message.env = (globalThis.Object.entries(object.env ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    return message;
  },
};

function createBaseExecRequest_EnvEntry(): ExecRequest_EnvEntry {
  return { key: "", value: "" };
}

export const ExecRequest_EnvEntry: MessageFns<ExecRequest_EnvEntry> = {
  encode(message: ExecRequest_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecRequest_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecRequest_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecRequest_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ExecRequest_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecRequest_EnvEntry>): ExecRequest_EnvEntry {
    return ExecRequest_EnvEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecRequest_EnvEntry>): ExecRequest_EnvEntry {
    const message = createBaseExecRequest_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseExecEvent(): ExecEvent {
  return { seq: 0, stdout: undefined, stderr: undefined, exit: undefined };
}

export const ExecEvent: MessageFns<ExecEvent> = {
  encode(message: ExecEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seq !== 0) {
      writer.uint32(8).uint64(message.seq);
    }
    if (message.stdout !== undefined) {
      writer.uint32(18).bytes(message.stdout);
    }
    if (message.stderr !== undefined) {
      writer.uint32(26).bytes(message.stderr);
    }
    if (message.exit !== undefined) {
      ExitEvent.encode(message.exit, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seq = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stdout = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stderr = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.exit = ExitEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecEvent {
    return {
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      stdout: isSet(object.stdout) ? Buffer.from(bytesFromBase64(object.stdout)) : undefined,
      stderr: isSet(object.stderr) ? Buffer.from(bytesFromBase64(object.stderr)) : undefined,
      exit: isSet(object.exit) ? ExitEvent.fromJSON(object.exit) : undefined,
    };
  },

  toJSON(message: ExecEvent): unknown {
    const obj: any = {};
    if (message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.stdout !== undefined) {
      obj.stdout = base64FromBytes(message.stdout);
    }
    if (message.stderr !== undefined) {
      obj.stderr = base64FromBytes(message.stderr);
    }
    if (message.exit !== undefined) {
      obj.exit = ExitEvent.toJSON(message.exit);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecEvent>): ExecEvent {
    return ExecEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecEvent>): ExecEvent {
    const message = createBaseExecEvent();
    message.seq = object.seq ?? 0;
    message.stdout = object.stdout ?? undefined;
    message.stderr = object.stderr ?? undefined;
    message.exit = (object.exit !== undefined && object.exit !== null) ? ExitEvent.fromPartial(object.exit) : undefined;
    return message;
  },
};

function createBaseExitEvent(): ExitEvent {
  return { exitCode: 0, cpuMs: 0, peakMemoryBytes: 0, durationMs: 0 };
}

export const ExitEvent: MessageFns<ExitEvent> = {
  encode(message: ExitEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exitCode !== 0) {
      writer.uint32(8).int32(message.exitCode);
    }
    if (message.cpuMs !== 0) {
      writer.uint32(16).uint64(message.cpuMs);
    }
    if (message.peakMemoryBytes !== 0) {
      writer.uint32(24).uint64(message.peakMemoryBytes);
    }
    if (message.durationMs !== 0) {
      writer.uint32(32).uint64(message.durationMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExitEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExitEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cpuMs = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.peakMemoryBytes = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.durationMs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExitEvent {
    return {
      exitCode: isSet(object.exitCode)
        ? globalThis.Number(object.exitCode)
        : isSet(object.exit_code)
        ? globalThis.Number(object.exit_code)
        : 0,
      cpuMs: isSet(object.cpuMs)
        ? globalThis.Number(object.cpuMs)
        : isSet(object.cpu_ms)
        ? globalThis.Number(object.cpu_ms)
        : 0,
      peakMemoryBytes: isSet(object.peakMemoryBytes)
        ? globalThis.Number(object.peakMemoryBytes)
        : isSet(object.peak_memory_bytes)
        ? globalThis.Number(object.peak_memory_bytes)
        : 0,
      durationMs: isSet(object.durationMs)
        ? globalThis.Number(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.Number(object.duration_ms)
        : 0,
    };
  },

  toJSON(message: ExitEvent): unknown {
    const obj: any = {};
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.cpuMs !== 0) {
      obj.cpuMs = Math.round(message.cpuMs);
    }
    if (message.peakMemoryBytes !== 0) {
      obj.peakMemoryBytes = Math.round(message.peakMemoryBytes);
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    return obj;
  },

  create(base?: DeepPartial<ExitEvent>): ExitEvent {
    return ExitEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExitEvent>): ExitEvent {
    const message = createBaseExitEvent();
    message.exitCode = object.exitCode ?? 0;
    message.cpuMs = object.cpuMs ?? 0;
    message.peakMemoryBytes = object.peakMemoryBytes ?? 0;
    message.durationMs = object.durationMs ?? 0;
    return message;
  },
};

function createBaseCreateSessionRequest(): CreateSessionRequest {
  return { shell: "", env: {} };
}

export const CreateSessionRequest: MessageFns<CreateSessionRequest> = {
  encode(message: CreateSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shell !== "") {
      writer.uint32(10).string(message.shell);
    }
    globalThis.Object.entries(message.env).forEach(([key, value]: [string, string]) => {
      CreateSessionRequest_EnvEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shell = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = CreateSessionRequest_EnvEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.env[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest {
    return {
      shell: isSet(object.shell) ? globalThis.String(object.shell) : "",
      env: isObject(object.env)
        ? (globalThis.Object.entries(object.env) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateSessionRequest): unknown {
    const obj: any = {};
    if (message.shell !== "") {
      obj.shell = message.shell;
    }
    if (message.env) {
      const entries = globalThis.Object.entries(message.env) as [string, string][];
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSessionRequest>): CreateSessionRequest {
    return CreateSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSessionRequest>): CreateSessionRequest {
    const message = createBaseCreateSessionRequest();
    message.shell = object.shell ?? "";
    message.env = (globalThis.Object.entries(object.env ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateSessionRequest_EnvEntry(): CreateSessionRequest_EnvEntry {
  return { key: "", value: "" };
}

export const CreateSessionRequest_EnvEntry: MessageFns<CreateSessionRequest_EnvEntry> = {
  encode(message: CreateSessionRequest_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionRequest_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateSessionRequest_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSessionRequest_EnvEntry>): CreateSessionRequest_EnvEntry {
    return CreateSessionRequest_EnvEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSessionRequest_EnvEntry>): CreateSessionRequest_EnvEntry {
    const message = createBaseCreateSessionRequest_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSessionResponse(): SessionResponse {
  return { sessionId: "" };
}

export const SessionResponse: MessageFns<SessionResponse> = {
  encode(message: SessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
    };
  },

  toJSON(message: SessionResponse): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create(base?: DeepPartial<SessionResponse>): SessionResponse {
    return SessionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionResponse>): SessionResponse {
    const message = createBaseSessionResponse();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseSessionExecRequest(): SessionExecRequest {
  return { sessionId: "", cmd: "", timeoutSeconds: 0 };
}

export const SessionExecRequest: MessageFns<SessionExecRequest> = {
  encode(message: SessionExecRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.cmd !== "") {
      writer.uint32(18).string(message.cmd);
    }
    if (message.timeoutSeconds !== 0) {
      writer.uint32(24).uint32(message.timeoutSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionExecRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionExecRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cmd = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timeoutSeconds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionExecRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      cmd: isSet(object.cmd) ? globalThis.String(object.cmd) : "",
      timeoutSeconds: isSet(object.timeoutSeconds)
        ? globalThis.Number(object.timeoutSeconds)
        : isSet(object.timeout_seconds)
        ? globalThis.Number(object.timeout_seconds)
        : 0,
    };
  },

  toJSON(message: SessionExecRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.cmd !== "") {
      obj.cmd = message.cmd;
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<SessionExecRequest>): SessionExecRequest {
    return SessionExecRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionExecRequest>): SessionExecRequest {
    const message = createBaseSessionExecRequest();
    message.sessionId = object.sessionId ?? "";
    message.cmd = object.cmd ?? "";
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    return message;
  },
};

function createBaseSessionInputRequest(): SessionInputRequest {
  return { sessionId: "", data: Buffer.alloc(0) };
}

export const SessionInputRequest: MessageFns<SessionInputRequest> = {
  encode(message: SessionInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionInputRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: SessionInputRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<SessionInputRequest>): SessionInputRequest {
    return SessionInputRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionInputRequest>): SessionInputRequest {
    const message = createBaseSessionInputRequest();
    message.sessionId = object.sessionId ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseDestroySessionRequest(): DestroySessionRequest {
  return { sessionId: "" };
}

export const DestroySessionRequest: MessageFns<DestroySessionRequest> = {
  encode(message: DestroySessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DestroySessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestroySessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestroySessionRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
    };
  },

  toJSON(message: DestroySessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create(base?: DeepPartial<DestroySessionRequest>): DestroySessionRequest {
    return DestroySessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DestroySessionRequest>): DestroySessionRequest {
    const message = createBaseDestroySessionRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseFileChunk(): FileChunk {
  return { path: "", data: Buffer.alloc(0), offset: 0, done: false };
}

export const FileChunk: MessageFns<FileChunk> = {
  encode(message: FileChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.offset !== 0) {
      writer.uint32(24).uint64(message.offset);
    }
    if (message.done !== false) {
      writer.uint32(32).bool(message.done);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.done = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileChunk {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      done: isSet(object.done) ? globalThis.Boolean(object.done) : false,
    };
  },

  toJSON(message: FileChunk): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.done !== false) {
      obj.done = message.done;
    }
    return obj;
  },

  create(base?: DeepPartial<FileChunk>): FileChunk {
    return FileChunk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileChunk>): FileChunk {
    const message = createBaseFileChunk();
    message.path = object.path ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    message.offset = object.offset ?? 0;
    message.done = object.done ?? false;
    return message;
  },
};

function createBasePutFileResponse(): PutFileResponse {
  return { bytesWritten: 0 };
}

export const PutFileResponse: MessageFns<PutFileResponse> = {
  encode(message: PutFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesWritten !== 0) {
      writer.uint32(8).uint64(message.bytesWritten);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PutFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bytesWritten = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutFileResponse {
    return {
      bytesWritten: isSet(object.bytesWritten)
        ? globalThis.Number(object.bytesWritten)
        : isSet(object.bytes_written)
        ? globalThis.Number(object.bytes_written)
        : 0,
    };
  },

  toJSON(message: PutFileResponse): unknown {
    const obj: any = {};
    if (message.bytesWritten !== 0) {
      obj.bytesWritten = Math.round(message.bytesWritten);
    }
    return obj;
  },

  create(base?: DeepPartial<PutFileResponse>): PutFileResponse {
    return PutFileResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PutFileResponse>): PutFileResponse {
    const message = createBasePutFileResponse();
    message.bytesWritten = object.bytesWritten ?? 0;
    return message;
  },
};

function createBaseGetFileRequest(): GetFileRequest {
  return { path: "" };
}

export const GetFileRequest: MessageFns<GetFileRequest> = {
  encode(message: GetFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFileRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: GetFileRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<GetFileRequest>): GetFileRequest {
    return GetFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetFileRequest>): GetFileRequest {
    const message = createBaseGetFileRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseListFilesRequest(): ListFilesRequest {
  return { path: "" };
}

export const ListFilesRequest: MessageFns<ListFilesRequest> = {
  encode(message: ListFilesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFilesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFilesRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: ListFilesRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFilesRequest>): ListFilesRequest {
    return ListFilesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFilesRequest>): ListFilesRequest {
    const message = createBaseListFilesRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseListFilesResponse(): ListFilesResponse {
  return { files: [] };
}

export const ListFilesResponse: MessageFns<ListFilesResponse> = {
  encode(message: ListFilesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.files) {
      FileInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFilesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.files.push(FileInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFilesResponse {
    return { files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => FileInfo.fromJSON(e)) : [] };
  },

  toJSON(message: ListFilesResponse): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => FileInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListFilesResponse>): ListFilesResponse {
    return ListFilesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFilesResponse>): ListFilesResponse {
    const message = createBaseListFilesResponse();
    message.files = object.files?.map((e) => FileInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFileInfo(): FileInfo {
  return { path: "", size: 0, isDir: false, modifiedAt: 0 };
}

export const FileInfo: MessageFns<FileInfo> = {
  encode(message: FileInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.size !== 0) {
      writer.uint32(16).uint64(message.size);
    }
    if (message.isDir !== false) {
      writer.uint32(24).bool(message.isDir);
    }
    if (message.modifiedAt !== 0) {
      writer.uint32(32).int64(message.modifiedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.size = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isDir = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.modifiedAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileInfo {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      isDir: isSet(object.isDir)
        ? globalThis.Boolean(object.isDir)
        : isSet(object.is_dir)
        ? globalThis.Boolean(object.is_dir)
        : false,
      modifiedAt: isSet(object.modifiedAt)
        ? globalThis.Number(object.modifiedAt)
        : isSet(object.modified_at)
        ? globalThis.Number(object.modified_at)
        : 0,
    };
  },

  toJSON(message: FileInfo): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.isDir !== false) {
      obj.isDir = message.isDir;
    }
    if (message.modifiedAt !== 0) {
      obj.modifiedAt = Math.round(message.modifiedAt);
    }
    return obj;
  },

  create(base?: DeepPartial<FileInfo>): FileInfo {
    return FileInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileInfo>): FileInfo {
    const message = createBaseFileInfo();
    message.path = object.path ?? "";
    message.size = object.size ?? 0;
    message.isDir = object.isDir ?? false;
    message.modifiedAt = object.modifiedAt ?? 0;
    return message;
  },
};

/**
 * GuestAgent runs inside each Firecracker microVM.
 * Communication is via gRPC over vsock (CID=3, port=52).
 */
export type GuestAgentDefinition = typeof GuestAgentDefinition;
export const GuestAgentDefinition = {
  name: "GuestAgent",
  fullName: "sandchest.agent.v1.GuestAgent",
  methods: {
    health: {
      name: "Health",
      requestType: Empty,
      requestStream: false,
      responseType: HealthResponse,
      responseStream: false,
      options: {},
    },
    exec: {
      name: "Exec",
      requestType: ExecRequest,
      requestStream: false,
      responseType: ExecEvent,
      responseStream: true,
      options: {},
    },
    createSession: {
      name: "CreateSession",
      requestType: CreateSessionRequest,
      requestStream: false,
      responseType: SessionResponse,
      responseStream: false,
      options: {},
    },
    sessionExec: {
      name: "SessionExec",
      requestType: SessionExecRequest,
      requestStream: false,
      responseType: ExecEvent,
      responseStream: true,
      options: {},
    },
    sessionInput: {
      name: "SessionInput",
      requestType: SessionInputRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    destroySession: {
      name: "DestroySession",
      requestType: DestroySessionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    putFile: {
      name: "PutFile",
      requestType: FileChunk,
      requestStream: true,
      responseType: PutFileResponse,
      responseStream: false,
      options: {},
    },
    getFile: {
      name: "GetFile",
      requestType: GetFileRequest,
      requestStream: false,
      responseType: FileChunk,
      responseStream: true,
      options: {},
    },
    listFiles: {
      name: "ListFiles",
      requestType: ListFilesRequest,
      requestStream: false,
      responseType: ListFilesResponse,
      responseStream: false,
      options: {},
    },
    shutdown: {
      name: "Shutdown",
      requestType: Empty,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
