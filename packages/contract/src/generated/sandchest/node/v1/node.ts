// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: sandchest/node/v1/node.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty } from "../../../google/protobuf/empty.js";

export const protobufPackage = "sandchest.node.v1";

export enum SandboxEventType {
  SANDBOX_EVENT_TYPE_UNSPECIFIED = 0,
  SANDBOX_EVENT_TYPE_CREATED = 1,
  SANDBOX_EVENT_TYPE_READY = 2,
  SANDBOX_EVENT_TYPE_STOPPED = 3,
  SANDBOX_EVENT_TYPE_FAILED = 4,
  SANDBOX_EVENT_TYPE_FORKED = 5,
  UNRECOGNIZED = -1,
}

export function sandboxEventTypeFromJSON(object: any): SandboxEventType {
  switch (object) {
    case 0:
    case "SANDBOX_EVENT_TYPE_UNSPECIFIED":
      return SandboxEventType.SANDBOX_EVENT_TYPE_UNSPECIFIED;
    case 1:
    case "SANDBOX_EVENT_TYPE_CREATED":
      return SandboxEventType.SANDBOX_EVENT_TYPE_CREATED;
    case 2:
    case "SANDBOX_EVENT_TYPE_READY":
      return SandboxEventType.SANDBOX_EVENT_TYPE_READY;
    case 3:
    case "SANDBOX_EVENT_TYPE_STOPPED":
      return SandboxEventType.SANDBOX_EVENT_TYPE_STOPPED;
    case 4:
    case "SANDBOX_EVENT_TYPE_FAILED":
      return SandboxEventType.SANDBOX_EVENT_TYPE_FAILED;
    case 5:
    case "SANDBOX_EVENT_TYPE_FORKED":
      return SandboxEventType.SANDBOX_EVENT_TYPE_FORKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SandboxEventType.UNRECOGNIZED;
  }
}

export function sandboxEventTypeToJSON(object: SandboxEventType): string {
  switch (object) {
    case SandboxEventType.SANDBOX_EVENT_TYPE_UNSPECIFIED:
      return "SANDBOX_EVENT_TYPE_UNSPECIFIED";
    case SandboxEventType.SANDBOX_EVENT_TYPE_CREATED:
      return "SANDBOX_EVENT_TYPE_CREATED";
    case SandboxEventType.SANDBOX_EVENT_TYPE_READY:
      return "SANDBOX_EVENT_TYPE_READY";
    case SandboxEventType.SANDBOX_EVENT_TYPE_STOPPED:
      return "SANDBOX_EVENT_TYPE_STOPPED";
    case SandboxEventType.SANDBOX_EVENT_TYPE_FAILED:
      return "SANDBOX_EVENT_TYPE_FAILED";
    case SandboxEventType.SANDBOX_EVENT_TYPE_FORKED:
      return "SANDBOX_EVENT_TYPE_FORKED";
    case SandboxEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CreateSandboxRequest {
  sandboxId: string;
  kernelRef: string;
  rootfsRef: string;
  cpuCores: number;
  memoryMb: number;
  diskGb: number;
  env: { [key: string]: string };
  ttlSeconds: number;
}

export interface CreateSandboxRequest_EnvEntry {
  key: string;
  value: string;
}

export interface CreateSandboxFromSnapshotRequest {
  sandboxId: string;
  snapshotRef: string;
  env: { [key: string]: string };
  ttlSeconds: number;
}

export interface CreateSandboxFromSnapshotRequest_EnvEntry {
  key: string;
  value: string;
}

export interface CreateSandboxResponse {
  sandboxId: string;
}

export interface ForkSandboxRequest {
  sourceSandboxId: string;
  newSandboxId: string;
}

export interface ForkSandboxResponse {
  sandboxId: string;
}

export interface NodeExecRequest {
  sandboxId: string;
  execId: string;
  cmd: string[];
  shellCmd: string;
  cwd: string;
  env: { [key: string]: string };
  timeoutSeconds: number;
}

export interface NodeExecRequest_EnvEntry {
  key: string;
  value: string;
}

export interface ExecEvent {
  seq: number;
  stdout?: Buffer | undefined;
  stderr?: Buffer | undefined;
  exit?: ExitEvent | undefined;
}

export interface ExitEvent {
  exitCode: number;
  cpuMs: number;
  peakMemoryBytes: number;
  durationMs: number;
}

export interface NodeCreateSessionRequest {
  sandboxId: string;
  sessionId: string;
  shell: string;
  env: { [key: string]: string };
}

export interface NodeCreateSessionRequest_EnvEntry {
  key: string;
  value: string;
}

export interface NodeCreateSessionResponse {
  sessionId: string;
}

export interface NodeSessionExecRequest {
  sandboxId: string;
  sessionId: string;
  execId: string;
  cmd: string;
  timeoutSeconds: number;
}

export interface NodeSessionInputRequest {
  sandboxId: string;
  sessionId: string;
  data: Buffer;
}

export interface NodeDestroySessionRequest {
  sandboxId: string;
  sessionId: string;
}

export interface NodeFileChunk {
  sandboxId: string;
  path: string;
  data: Buffer;
  offset: number;
  done: boolean;
}

export interface NodePutFileResponse {
  bytesWritten: number;
}

export interface NodeGetFileRequest {
  sandboxId: string;
  path: string;
}

export interface NodeListFilesRequest {
  sandboxId: string;
  path: string;
}

export interface NodeListFilesResponse {
  files: NodeFileInfo[];
}

export interface NodeFileInfo {
  path: string;
  size: number;
  isDir: boolean;
  modifiedAt: number;
}

export interface CollectArtifactsRequest {
  sandboxId: string;
  paths: string[];
}

export interface CollectArtifactsResponse {
  artifacts: CollectedArtifact[];
}

export interface CollectedArtifact {
  name: string;
  mime: string;
  bytes: number;
  sha256: string;
  ref: string;
}

export interface StopSandboxRequest {
  sandboxId: string;
}

export interface StopSandboxResponse {
  sandboxId: string;
}

export interface DestroySandboxRequest {
  sandboxId: string;
}

/** Wraps all Node -> Control event types in a single oneof. */
export interface NodeToControl {
  heartbeat?: Heartbeat | undefined;
  execOutput?: ExecOutput | undefined;
  sessionOutput?: SessionOutput | undefined;
  execCompleted?: ExecCompleted | undefined;
  sandboxEvent?: SandboxEvent | undefined;
  artifactReport?: ArtifactReport | undefined;
}

/** Acknowledgement / reserved for future control-plane-to-node commands. */
export interface ControlToNode {
  noop: string;
}

export interface Heartbeat {
  nodeId: string;
  activeSandboxIds: string[];
  slotsTotal: number;
  slotsUsed: number;
  snapshotIds: string[];
}

export interface ExecOutput {
  execId: string;
  seq: number;
  stdout?: Buffer | undefined;
  stderr?: Buffer | undefined;
}

export interface SessionOutput {
  sessionId: string;
  seq: number;
  stdout?: Buffer | undefined;
  stderr?: Buffer | undefined;
}

export interface ExecCompleted {
  execId: string;
  exitCode: number;
  cpuMs: number;
  peakMemoryBytes: number;
  durationMs: number;
}

export interface SandboxEvent {
  sandboxId: string;
  eventType: SandboxEventType;
  message: string;
}

export interface ArtifactReport {
  sandboxId: string;
  artifacts: ReportedArtifact[];
}

export interface ReportedArtifact {
  name: string;
  mime: string;
  bytes: number;
  sha256: string;
  ref: string;
}

function createBaseCreateSandboxRequest(): CreateSandboxRequest {
  return { sandboxId: "", kernelRef: "", rootfsRef: "", cpuCores: 0, memoryMb: 0, diskGb: 0, env: {}, ttlSeconds: 0 };
}

export const CreateSandboxRequest: MessageFns<CreateSandboxRequest> = {
  encode(message: CreateSandboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.kernelRef !== "") {
      writer.uint32(18).string(message.kernelRef);
    }
    if (message.rootfsRef !== "") {
      writer.uint32(26).string(message.rootfsRef);
    }
    if (message.cpuCores !== 0) {
      writer.uint32(32).uint32(message.cpuCores);
    }
    if (message.memoryMb !== 0) {
      writer.uint32(40).uint32(message.memoryMb);
    }
    if (message.diskGb !== 0) {
      writer.uint32(48).uint32(message.diskGb);
    }
    globalThis.Object.entries(message.env).forEach(([key, value]: [string, string]) => {
      CreateSandboxRequest_EnvEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.ttlSeconds !== 0) {
      writer.uint32(64).uint32(message.ttlSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSandboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSandboxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.kernelRef = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rootfsRef = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.cpuCores = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.memoryMb = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.diskGb = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = CreateSandboxRequest_EnvEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.env[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ttlSeconds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSandboxRequest {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
      kernelRef: isSet(object.kernelRef)
        ? globalThis.String(object.kernelRef)
        : isSet(object.kernel_ref)
        ? globalThis.String(object.kernel_ref)
        : "",
      rootfsRef: isSet(object.rootfsRef)
        ? globalThis.String(object.rootfsRef)
        : isSet(object.rootfs_ref)
        ? globalThis.String(object.rootfs_ref)
        : "",
      cpuCores: isSet(object.cpuCores)
        ? globalThis.Number(object.cpuCores)
        : isSet(object.cpu_cores)
        ? globalThis.Number(object.cpu_cores)
        : 0,
      memoryMb: isSet(object.memoryMb)
        ? globalThis.Number(object.memoryMb)
        : isSet(object.memory_mb)
        ? globalThis.Number(object.memory_mb)
        : 0,
      diskGb: isSet(object.diskGb)
        ? globalThis.Number(object.diskGb)
        : isSet(object.disk_gb)
        ? globalThis.Number(object.disk_gb)
        : 0,
      env: isObject(object.env)
        ? (globalThis.Object.entries(object.env) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      ttlSeconds: isSet(object.ttlSeconds)
        ? globalThis.Number(object.ttlSeconds)
        : isSet(object.ttl_seconds)
        ? globalThis.Number(object.ttl_seconds)
        : 0,
    };
  },

  toJSON(message: CreateSandboxRequest): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.kernelRef !== "") {
      obj.kernelRef = message.kernelRef;
    }
    if (message.rootfsRef !== "") {
      obj.rootfsRef = message.rootfsRef;
    }
    if (message.cpuCores !== 0) {
      obj.cpuCores = Math.round(message.cpuCores);
    }
    if (message.memoryMb !== 0) {
      obj.memoryMb = Math.round(message.memoryMb);
    }
    if (message.diskGb !== 0) {
      obj.diskGb = Math.round(message.diskGb);
    }
    if (message.env) {
      const entries = globalThis.Object.entries(message.env) as [string, string][];
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    if (message.ttlSeconds !== 0) {
      obj.ttlSeconds = Math.round(message.ttlSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSandboxRequest>): CreateSandboxRequest {
    return CreateSandboxRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSandboxRequest>): CreateSandboxRequest {
    const message = createBaseCreateSandboxRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.kernelRef = object.kernelRef ?? "";
    message.rootfsRef = object.rootfsRef ?? "";
    message.cpuCores = object.cpuCores ?? 0;
    message.memoryMb = object.memoryMb ?? 0;
    message.diskGb = object.diskGb ?? 0;
    message.env = (globalThis.Object.entries(object.env ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.ttlSeconds = object.ttlSeconds ?? 0;
    return message;
  },
};

function createBaseCreateSandboxRequest_EnvEntry(): CreateSandboxRequest_EnvEntry {
  return { key: "", value: "" };
}

export const CreateSandboxRequest_EnvEntry: MessageFns<CreateSandboxRequest_EnvEntry> = {
  encode(message: CreateSandboxRequest_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSandboxRequest_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSandboxRequest_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSandboxRequest_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateSandboxRequest_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSandboxRequest_EnvEntry>): CreateSandboxRequest_EnvEntry {
    return CreateSandboxRequest_EnvEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSandboxRequest_EnvEntry>): CreateSandboxRequest_EnvEntry {
    const message = createBaseCreateSandboxRequest_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateSandboxFromSnapshotRequest(): CreateSandboxFromSnapshotRequest {
  return { sandboxId: "", snapshotRef: "", env: {}, ttlSeconds: 0 };
}

export const CreateSandboxFromSnapshotRequest: MessageFns<CreateSandboxFromSnapshotRequest> = {
  encode(message: CreateSandboxFromSnapshotRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.snapshotRef !== "") {
      writer.uint32(18).string(message.snapshotRef);
    }
    globalThis.Object.entries(message.env).forEach(([key, value]: [string, string]) => {
      CreateSandboxFromSnapshotRequest_EnvEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.ttlSeconds !== 0) {
      writer.uint32(32).uint32(message.ttlSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSandboxFromSnapshotRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSandboxFromSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.snapshotRef = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = CreateSandboxFromSnapshotRequest_EnvEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.env[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ttlSeconds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSandboxFromSnapshotRequest {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
      snapshotRef: isSet(object.snapshotRef)
        ? globalThis.String(object.snapshotRef)
        : isSet(object.snapshot_ref)
        ? globalThis.String(object.snapshot_ref)
        : "",
      env: isObject(object.env)
        ? (globalThis.Object.entries(object.env) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      ttlSeconds: isSet(object.ttlSeconds)
        ? globalThis.Number(object.ttlSeconds)
        : isSet(object.ttl_seconds)
        ? globalThis.Number(object.ttl_seconds)
        : 0,
    };
  },

  toJSON(message: CreateSandboxFromSnapshotRequest): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.snapshotRef !== "") {
      obj.snapshotRef = message.snapshotRef;
    }
    if (message.env) {
      const entries = globalThis.Object.entries(message.env) as [string, string][];
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    if (message.ttlSeconds !== 0) {
      obj.ttlSeconds = Math.round(message.ttlSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSandboxFromSnapshotRequest>): CreateSandboxFromSnapshotRequest {
    return CreateSandboxFromSnapshotRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSandboxFromSnapshotRequest>): CreateSandboxFromSnapshotRequest {
    const message = createBaseCreateSandboxFromSnapshotRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.snapshotRef = object.snapshotRef ?? "";
    message.env = (globalThis.Object.entries(object.env ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.ttlSeconds = object.ttlSeconds ?? 0;
    return message;
  },
};

function createBaseCreateSandboxFromSnapshotRequest_EnvEntry(): CreateSandboxFromSnapshotRequest_EnvEntry {
  return { key: "", value: "" };
}

export const CreateSandboxFromSnapshotRequest_EnvEntry: MessageFns<CreateSandboxFromSnapshotRequest_EnvEntry> = {
  encode(message: CreateSandboxFromSnapshotRequest_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSandboxFromSnapshotRequest_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSandboxFromSnapshotRequest_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSandboxFromSnapshotRequest_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateSandboxFromSnapshotRequest_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSandboxFromSnapshotRequest_EnvEntry>): CreateSandboxFromSnapshotRequest_EnvEntry {
    return CreateSandboxFromSnapshotRequest_EnvEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateSandboxFromSnapshotRequest_EnvEntry>,
  ): CreateSandboxFromSnapshotRequest_EnvEntry {
    const message = createBaseCreateSandboxFromSnapshotRequest_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateSandboxResponse(): CreateSandboxResponse {
  return { sandboxId: "" };
}

export const CreateSandboxResponse: MessageFns<CreateSandboxResponse> = {
  encode(message: CreateSandboxResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSandboxResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSandboxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSandboxResponse {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
    };
  },

  toJSON(message: CreateSandboxResponse): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSandboxResponse>): CreateSandboxResponse {
    return CreateSandboxResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSandboxResponse>): CreateSandboxResponse {
    const message = createBaseCreateSandboxResponse();
    message.sandboxId = object.sandboxId ?? "";
    return message;
  },
};

function createBaseForkSandboxRequest(): ForkSandboxRequest {
  return { sourceSandboxId: "", newSandboxId: "" };
}

export const ForkSandboxRequest: MessageFns<ForkSandboxRequest> = {
  encode(message: ForkSandboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceSandboxId !== "") {
      writer.uint32(10).string(message.sourceSandboxId);
    }
    if (message.newSandboxId !== "") {
      writer.uint32(18).string(message.newSandboxId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForkSandboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForkSandboxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceSandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newSandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForkSandboxRequest {
    return {
      sourceSandboxId: isSet(object.sourceSandboxId)
        ? globalThis.String(object.sourceSandboxId)
        : isSet(object.source_sandbox_id)
        ? globalThis.String(object.source_sandbox_id)
        : "",
      newSandboxId: isSet(object.newSandboxId)
        ? globalThis.String(object.newSandboxId)
        : isSet(object.new_sandbox_id)
        ? globalThis.String(object.new_sandbox_id)
        : "",
    };
  },

  toJSON(message: ForkSandboxRequest): unknown {
    const obj: any = {};
    if (message.sourceSandboxId !== "") {
      obj.sourceSandboxId = message.sourceSandboxId;
    }
    if (message.newSandboxId !== "") {
      obj.newSandboxId = message.newSandboxId;
    }
    return obj;
  },

  create(base?: DeepPartial<ForkSandboxRequest>): ForkSandboxRequest {
    return ForkSandboxRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForkSandboxRequest>): ForkSandboxRequest {
    const message = createBaseForkSandboxRequest();
    message.sourceSandboxId = object.sourceSandboxId ?? "";
    message.newSandboxId = object.newSandboxId ?? "";
    return message;
  },
};

function createBaseForkSandboxResponse(): ForkSandboxResponse {
  return { sandboxId: "" };
}

export const ForkSandboxResponse: MessageFns<ForkSandboxResponse> = {
  encode(message: ForkSandboxResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForkSandboxResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForkSandboxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForkSandboxResponse {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
    };
  },

  toJSON(message: ForkSandboxResponse): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },

  create(base?: DeepPartial<ForkSandboxResponse>): ForkSandboxResponse {
    return ForkSandboxResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForkSandboxResponse>): ForkSandboxResponse {
    const message = createBaseForkSandboxResponse();
    message.sandboxId = object.sandboxId ?? "";
    return message;
  },
};

function createBaseNodeExecRequest(): NodeExecRequest {
  return { sandboxId: "", execId: "", cmd: [], shellCmd: "", cwd: "", env: {}, timeoutSeconds: 0 };
}

export const NodeExecRequest: MessageFns<NodeExecRequest> = {
  encode(message: NodeExecRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.execId !== "") {
      writer.uint32(18).string(message.execId);
    }
    for (const v of message.cmd) {
      writer.uint32(26).string(v!);
    }
    if (message.shellCmd !== "") {
      writer.uint32(34).string(message.shellCmd);
    }
    if (message.cwd !== "") {
      writer.uint32(42).string(message.cwd);
    }
    globalThis.Object.entries(message.env).forEach(([key, value]: [string, string]) => {
      NodeExecRequest_EnvEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.timeoutSeconds !== 0) {
      writer.uint32(56).uint32(message.timeoutSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeExecRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeExecRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.execId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cmd.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shellCmd = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cwd = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = NodeExecRequest_EnvEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.env[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.timeoutSeconds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeExecRequest {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
      execId: isSet(object.execId)
        ? globalThis.String(object.execId)
        : isSet(object.exec_id)
        ? globalThis.String(object.exec_id)
        : "",
      cmd: globalThis.Array.isArray(object?.cmd) ? object.cmd.map((e: any) => globalThis.String(e)) : [],
      shellCmd: isSet(object.shellCmd)
        ? globalThis.String(object.shellCmd)
        : isSet(object.shell_cmd)
        ? globalThis.String(object.shell_cmd)
        : "",
      cwd: isSet(object.cwd) ? globalThis.String(object.cwd) : "",
      env: isObject(object.env)
        ? (globalThis.Object.entries(object.env) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      timeoutSeconds: isSet(object.timeoutSeconds)
        ? globalThis.Number(object.timeoutSeconds)
        : isSet(object.timeout_seconds)
        ? globalThis.Number(object.timeout_seconds)
        : 0,
    };
  },

  toJSON(message: NodeExecRequest): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.cmd?.length) {
      obj.cmd = message.cmd;
    }
    if (message.shellCmd !== "") {
      obj.shellCmd = message.shellCmd;
    }
    if (message.cwd !== "") {
      obj.cwd = message.cwd;
    }
    if (message.env) {
      const entries = globalThis.Object.entries(message.env) as [string, string][];
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeExecRequest>): NodeExecRequest {
    return NodeExecRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeExecRequest>): NodeExecRequest {
    const message = createBaseNodeExecRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.execId = object.execId ?? "";
    message.cmd = object.cmd?.map((e) => e) || [];
    message.shellCmd = object.shellCmd ?? "";
    message.cwd = object.cwd ?? "";
    message.env = (globalThis.Object.entries(object.env ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    return message;
  },
};

function createBaseNodeExecRequest_EnvEntry(): NodeExecRequest_EnvEntry {
  return { key: "", value: "" };
}

export const NodeExecRequest_EnvEntry: MessageFns<NodeExecRequest_EnvEntry> = {
  encode(message: NodeExecRequest_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeExecRequest_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeExecRequest_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeExecRequest_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodeExecRequest_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeExecRequest_EnvEntry>): NodeExecRequest_EnvEntry {
    return NodeExecRequest_EnvEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeExecRequest_EnvEntry>): NodeExecRequest_EnvEntry {
    const message = createBaseNodeExecRequest_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseExecEvent(): ExecEvent {
  return { seq: 0, stdout: undefined, stderr: undefined, exit: undefined };
}

export const ExecEvent: MessageFns<ExecEvent> = {
  encode(message: ExecEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seq !== 0) {
      writer.uint32(8).uint64(message.seq);
    }
    if (message.stdout !== undefined) {
      writer.uint32(18).bytes(message.stdout);
    }
    if (message.stderr !== undefined) {
      writer.uint32(26).bytes(message.stderr);
    }
    if (message.exit !== undefined) {
      ExitEvent.encode(message.exit, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seq = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stdout = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stderr = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.exit = ExitEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecEvent {
    return {
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      stdout: isSet(object.stdout) ? Buffer.from(bytesFromBase64(object.stdout)) : undefined,
      stderr: isSet(object.stderr) ? Buffer.from(bytesFromBase64(object.stderr)) : undefined,
      exit: isSet(object.exit) ? ExitEvent.fromJSON(object.exit) : undefined,
    };
  },

  toJSON(message: ExecEvent): unknown {
    const obj: any = {};
    if (message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.stdout !== undefined) {
      obj.stdout = base64FromBytes(message.stdout);
    }
    if (message.stderr !== undefined) {
      obj.stderr = base64FromBytes(message.stderr);
    }
    if (message.exit !== undefined) {
      obj.exit = ExitEvent.toJSON(message.exit);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecEvent>): ExecEvent {
    return ExecEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecEvent>): ExecEvent {
    const message = createBaseExecEvent();
    message.seq = object.seq ?? 0;
    message.stdout = object.stdout ?? undefined;
    message.stderr = object.stderr ?? undefined;
    message.exit = (object.exit !== undefined && object.exit !== null) ? ExitEvent.fromPartial(object.exit) : undefined;
    return message;
  },
};

function createBaseExitEvent(): ExitEvent {
  return { exitCode: 0, cpuMs: 0, peakMemoryBytes: 0, durationMs: 0 };
}

export const ExitEvent: MessageFns<ExitEvent> = {
  encode(message: ExitEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exitCode !== 0) {
      writer.uint32(8).int32(message.exitCode);
    }
    if (message.cpuMs !== 0) {
      writer.uint32(16).uint64(message.cpuMs);
    }
    if (message.peakMemoryBytes !== 0) {
      writer.uint32(24).uint64(message.peakMemoryBytes);
    }
    if (message.durationMs !== 0) {
      writer.uint32(32).uint64(message.durationMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExitEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExitEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cpuMs = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.peakMemoryBytes = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.durationMs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExitEvent {
    return {
      exitCode: isSet(object.exitCode)
        ? globalThis.Number(object.exitCode)
        : isSet(object.exit_code)
        ? globalThis.Number(object.exit_code)
        : 0,
      cpuMs: isSet(object.cpuMs)
        ? globalThis.Number(object.cpuMs)
        : isSet(object.cpu_ms)
        ? globalThis.Number(object.cpu_ms)
        : 0,
      peakMemoryBytes: isSet(object.peakMemoryBytes)
        ? globalThis.Number(object.peakMemoryBytes)
        : isSet(object.peak_memory_bytes)
        ? globalThis.Number(object.peak_memory_bytes)
        : 0,
      durationMs: isSet(object.durationMs)
        ? globalThis.Number(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.Number(object.duration_ms)
        : 0,
    };
  },

  toJSON(message: ExitEvent): unknown {
    const obj: any = {};
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.cpuMs !== 0) {
      obj.cpuMs = Math.round(message.cpuMs);
    }
    if (message.peakMemoryBytes !== 0) {
      obj.peakMemoryBytes = Math.round(message.peakMemoryBytes);
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    return obj;
  },

  create(base?: DeepPartial<ExitEvent>): ExitEvent {
    return ExitEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExitEvent>): ExitEvent {
    const message = createBaseExitEvent();
    message.exitCode = object.exitCode ?? 0;
    message.cpuMs = object.cpuMs ?? 0;
    message.peakMemoryBytes = object.peakMemoryBytes ?? 0;
    message.durationMs = object.durationMs ?? 0;
    return message;
  },
};

function createBaseNodeCreateSessionRequest(): NodeCreateSessionRequest {
  return { sandboxId: "", sessionId: "", shell: "", env: {} };
}

export const NodeCreateSessionRequest: MessageFns<NodeCreateSessionRequest> = {
  encode(message: NodeCreateSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.shell !== "") {
      writer.uint32(26).string(message.shell);
    }
    globalThis.Object.entries(message.env).forEach(([key, value]: [string, string]) => {
      NodeCreateSessionRequest_EnvEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeCreateSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeCreateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.shell = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = NodeCreateSessionRequest_EnvEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.env[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeCreateSessionRequest {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      shell: isSet(object.shell) ? globalThis.String(object.shell) : "",
      env: isObject(object.env)
        ? (globalThis.Object.entries(object.env) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: NodeCreateSessionRequest): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.shell !== "") {
      obj.shell = message.shell;
    }
    if (message.env) {
      const entries = globalThis.Object.entries(message.env) as [string, string][];
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<NodeCreateSessionRequest>): NodeCreateSessionRequest {
    return NodeCreateSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeCreateSessionRequest>): NodeCreateSessionRequest {
    const message = createBaseNodeCreateSessionRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.shell = object.shell ?? "";
    message.env = (globalThis.Object.entries(object.env ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseNodeCreateSessionRequest_EnvEntry(): NodeCreateSessionRequest_EnvEntry {
  return { key: "", value: "" };
}

export const NodeCreateSessionRequest_EnvEntry: MessageFns<NodeCreateSessionRequest_EnvEntry> = {
  encode(message: NodeCreateSessionRequest_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeCreateSessionRequest_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeCreateSessionRequest_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeCreateSessionRequest_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodeCreateSessionRequest_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeCreateSessionRequest_EnvEntry>): NodeCreateSessionRequest_EnvEntry {
    return NodeCreateSessionRequest_EnvEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeCreateSessionRequest_EnvEntry>): NodeCreateSessionRequest_EnvEntry {
    const message = createBaseNodeCreateSessionRequest_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNodeCreateSessionResponse(): NodeCreateSessionResponse {
  return { sessionId: "" };
}

export const NodeCreateSessionResponse: MessageFns<NodeCreateSessionResponse> = {
  encode(message: NodeCreateSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeCreateSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeCreateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeCreateSessionResponse {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
    };
  },

  toJSON(message: NodeCreateSessionResponse): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeCreateSessionResponse>): NodeCreateSessionResponse {
    return NodeCreateSessionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeCreateSessionResponse>): NodeCreateSessionResponse {
    const message = createBaseNodeCreateSessionResponse();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseNodeSessionExecRequest(): NodeSessionExecRequest {
  return { sandboxId: "", sessionId: "", execId: "", cmd: "", timeoutSeconds: 0 };
}

export const NodeSessionExecRequest: MessageFns<NodeSessionExecRequest> = {
  encode(message: NodeSessionExecRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.execId !== "") {
      writer.uint32(26).string(message.execId);
    }
    if (message.cmd !== "") {
      writer.uint32(34).string(message.cmd);
    }
    if (message.timeoutSeconds !== 0) {
      writer.uint32(40).uint32(message.timeoutSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeSessionExecRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeSessionExecRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.execId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cmd = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timeoutSeconds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeSessionExecRequest {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      execId: isSet(object.execId)
        ? globalThis.String(object.execId)
        : isSet(object.exec_id)
        ? globalThis.String(object.exec_id)
        : "",
      cmd: isSet(object.cmd) ? globalThis.String(object.cmd) : "",
      timeoutSeconds: isSet(object.timeoutSeconds)
        ? globalThis.Number(object.timeoutSeconds)
        : isSet(object.timeout_seconds)
        ? globalThis.Number(object.timeout_seconds)
        : 0,
    };
  },

  toJSON(message: NodeSessionExecRequest): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.cmd !== "") {
      obj.cmd = message.cmd;
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeSessionExecRequest>): NodeSessionExecRequest {
    return NodeSessionExecRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeSessionExecRequest>): NodeSessionExecRequest {
    const message = createBaseNodeSessionExecRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.execId = object.execId ?? "";
    message.cmd = object.cmd ?? "";
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    return message;
  },
};

function createBaseNodeSessionInputRequest(): NodeSessionInputRequest {
  return { sandboxId: "", sessionId: "", data: Buffer.alloc(0) };
}

export const NodeSessionInputRequest: MessageFns<NodeSessionInputRequest> = {
  encode(message: NodeSessionInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeSessionInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeSessionInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeSessionInputRequest {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: NodeSessionInputRequest): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeSessionInputRequest>): NodeSessionInputRequest {
    return NodeSessionInputRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeSessionInputRequest>): NodeSessionInputRequest {
    const message = createBaseNodeSessionInputRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseNodeDestroySessionRequest(): NodeDestroySessionRequest {
  return { sandboxId: "", sessionId: "" };
}

export const NodeDestroySessionRequest: MessageFns<NodeDestroySessionRequest> = {
  encode(message: NodeDestroySessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeDestroySessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeDestroySessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeDestroySessionRequest {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
    };
  },

  toJSON(message: NodeDestroySessionRequest): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeDestroySessionRequest>): NodeDestroySessionRequest {
    return NodeDestroySessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeDestroySessionRequest>): NodeDestroySessionRequest {
    const message = createBaseNodeDestroySessionRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseNodeFileChunk(): NodeFileChunk {
  return { sandboxId: "", path: "", data: Buffer.alloc(0), offset: 0, done: false };
}

export const NodeFileChunk: MessageFns<NodeFileChunk> = {
  encode(message: NodeFileChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.offset !== 0) {
      writer.uint32(32).uint64(message.offset);
    }
    if (message.done !== false) {
      writer.uint32(40).bool(message.done);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeFileChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeFileChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.done = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeFileChunk {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      done: isSet(object.done) ? globalThis.Boolean(object.done) : false,
    };
  },

  toJSON(message: NodeFileChunk): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.done !== false) {
      obj.done = message.done;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeFileChunk>): NodeFileChunk {
    return NodeFileChunk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeFileChunk>): NodeFileChunk {
    const message = createBaseNodeFileChunk();
    message.sandboxId = object.sandboxId ?? "";
    message.path = object.path ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    message.offset = object.offset ?? 0;
    message.done = object.done ?? false;
    return message;
  },
};

function createBaseNodePutFileResponse(): NodePutFileResponse {
  return { bytesWritten: 0 };
}

export const NodePutFileResponse: MessageFns<NodePutFileResponse> = {
  encode(message: NodePutFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesWritten !== 0) {
      writer.uint32(8).uint64(message.bytesWritten);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePutFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePutFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bytesWritten = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePutFileResponse {
    return {
      bytesWritten: isSet(object.bytesWritten)
        ? globalThis.Number(object.bytesWritten)
        : isSet(object.bytes_written)
        ? globalThis.Number(object.bytes_written)
        : 0,
    };
  },

  toJSON(message: NodePutFileResponse): unknown {
    const obj: any = {};
    if (message.bytesWritten !== 0) {
      obj.bytesWritten = Math.round(message.bytesWritten);
    }
    return obj;
  },

  create(base?: DeepPartial<NodePutFileResponse>): NodePutFileResponse {
    return NodePutFileResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePutFileResponse>): NodePutFileResponse {
    const message = createBaseNodePutFileResponse();
    message.bytesWritten = object.bytesWritten ?? 0;
    return message;
  },
};

function createBaseNodeGetFileRequest(): NodeGetFileRequest {
  return { sandboxId: "", path: "" };
}

export const NodeGetFileRequest: MessageFns<NodeGetFileRequest> = {
  encode(message: NodeGetFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGetFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGetFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGetFileRequest {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: NodeGetFileRequest): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeGetFileRequest>): NodeGetFileRequest {
    return NodeGetFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeGetFileRequest>): NodeGetFileRequest {
    const message = createBaseNodeGetFileRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseNodeListFilesRequest(): NodeListFilesRequest {
  return { sandboxId: "", path: "" };
}

export const NodeListFilesRequest: MessageFns<NodeListFilesRequest> = {
  encode(message: NodeListFilesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeListFilesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeListFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeListFilesRequest {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: NodeListFilesRequest): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeListFilesRequest>): NodeListFilesRequest {
    return NodeListFilesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeListFilesRequest>): NodeListFilesRequest {
    const message = createBaseNodeListFilesRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseNodeListFilesResponse(): NodeListFilesResponse {
  return { files: [] };
}

export const NodeListFilesResponse: MessageFns<NodeListFilesResponse> = {
  encode(message: NodeListFilesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.files) {
      NodeFileInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeListFilesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeListFilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.files.push(NodeFileInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeListFilesResponse {
    return {
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => NodeFileInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: NodeListFilesResponse): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => NodeFileInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NodeListFilesResponse>): NodeListFilesResponse {
    return NodeListFilesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeListFilesResponse>): NodeListFilesResponse {
    const message = createBaseNodeListFilesResponse();
    message.files = object.files?.map((e) => NodeFileInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNodeFileInfo(): NodeFileInfo {
  return { path: "", size: 0, isDir: false, modifiedAt: 0 };
}

export const NodeFileInfo: MessageFns<NodeFileInfo> = {
  encode(message: NodeFileInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.size !== 0) {
      writer.uint32(16).uint64(message.size);
    }
    if (message.isDir !== false) {
      writer.uint32(24).bool(message.isDir);
    }
    if (message.modifiedAt !== 0) {
      writer.uint32(32).int64(message.modifiedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeFileInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeFileInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.size = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isDir = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.modifiedAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeFileInfo {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      isDir: isSet(object.isDir)
        ? globalThis.Boolean(object.isDir)
        : isSet(object.is_dir)
        ? globalThis.Boolean(object.is_dir)
        : false,
      modifiedAt: isSet(object.modifiedAt)
        ? globalThis.Number(object.modifiedAt)
        : isSet(object.modified_at)
        ? globalThis.Number(object.modified_at)
        : 0,
    };
  },

  toJSON(message: NodeFileInfo): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.isDir !== false) {
      obj.isDir = message.isDir;
    }
    if (message.modifiedAt !== 0) {
      obj.modifiedAt = Math.round(message.modifiedAt);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeFileInfo>): NodeFileInfo {
    return NodeFileInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeFileInfo>): NodeFileInfo {
    const message = createBaseNodeFileInfo();
    message.path = object.path ?? "";
    message.size = object.size ?? 0;
    message.isDir = object.isDir ?? false;
    message.modifiedAt = object.modifiedAt ?? 0;
    return message;
  },
};

function createBaseCollectArtifactsRequest(): CollectArtifactsRequest {
  return { sandboxId: "", paths: [] };
}

export const CollectArtifactsRequest: MessageFns<CollectArtifactsRequest> = {
  encode(message: CollectArtifactsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    for (const v of message.paths) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectArtifactsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectArtifactsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paths.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectArtifactsRequest {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
      paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CollectArtifactsRequest): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.paths?.length) {
      obj.paths = message.paths;
    }
    return obj;
  },

  create(base?: DeepPartial<CollectArtifactsRequest>): CollectArtifactsRequest {
    return CollectArtifactsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectArtifactsRequest>): CollectArtifactsRequest {
    const message = createBaseCollectArtifactsRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.paths = object.paths?.map((e) => e) || [];
    return message;
  },
};

function createBaseCollectArtifactsResponse(): CollectArtifactsResponse {
  return { artifacts: [] };
}

export const CollectArtifactsResponse: MessageFns<CollectArtifactsResponse> = {
  encode(message: CollectArtifactsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.artifacts) {
      CollectedArtifact.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectArtifactsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectArtifactsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.artifacts.push(CollectedArtifact.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectArtifactsResponse {
    return {
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => CollectedArtifact.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CollectArtifactsResponse): unknown {
    const obj: any = {};
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => CollectedArtifact.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CollectArtifactsResponse>): CollectArtifactsResponse {
    return CollectArtifactsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectArtifactsResponse>): CollectArtifactsResponse {
    const message = createBaseCollectArtifactsResponse();
    message.artifacts = object.artifacts?.map((e) => CollectedArtifact.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCollectedArtifact(): CollectedArtifact {
  return { name: "", mime: "", bytes: 0, sha256: "", ref: "" };
}

export const CollectedArtifact: MessageFns<CollectedArtifact> = {
  encode(message: CollectedArtifact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.mime !== "") {
      writer.uint32(18).string(message.mime);
    }
    if (message.bytes !== 0) {
      writer.uint32(24).uint64(message.bytes);
    }
    if (message.sha256 !== "") {
      writer.uint32(34).string(message.sha256);
    }
    if (message.ref !== "") {
      writer.uint32(42).string(message.ref);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectedArtifact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectedArtifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.bytes = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sha256 = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectedArtifact {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      mime: isSet(object.mime) ? globalThis.String(object.mime) : "",
      bytes: isSet(object.bytes) ? globalThis.Number(object.bytes) : 0,
      sha256: isSet(object.sha256) ? globalThis.String(object.sha256) : "",
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
    };
  },

  toJSON(message: CollectedArtifact): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.mime !== "") {
      obj.mime = message.mime;
    }
    if (message.bytes !== 0) {
      obj.bytes = Math.round(message.bytes);
    }
    if (message.sha256 !== "") {
      obj.sha256 = message.sha256;
    }
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    return obj;
  },

  create(base?: DeepPartial<CollectedArtifact>): CollectedArtifact {
    return CollectedArtifact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectedArtifact>): CollectedArtifact {
    const message = createBaseCollectedArtifact();
    message.name = object.name ?? "";
    message.mime = object.mime ?? "";
    message.bytes = object.bytes ?? 0;
    message.sha256 = object.sha256 ?? "";
    message.ref = object.ref ?? "";
    return message;
  },
};

function createBaseStopSandboxRequest(): StopSandboxRequest {
  return { sandboxId: "" };
}

export const StopSandboxRequest: MessageFns<StopSandboxRequest> = {
  encode(message: StopSandboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopSandboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopSandboxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopSandboxRequest {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
    };
  },

  toJSON(message: StopSandboxRequest): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },

  create(base?: DeepPartial<StopSandboxRequest>): StopSandboxRequest {
    return StopSandboxRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopSandboxRequest>): StopSandboxRequest {
    const message = createBaseStopSandboxRequest();
    message.sandboxId = object.sandboxId ?? "";
    return message;
  },
};

function createBaseStopSandboxResponse(): StopSandboxResponse {
  return { sandboxId: "" };
}

export const StopSandboxResponse: MessageFns<StopSandboxResponse> = {
  encode(message: StopSandboxResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopSandboxResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopSandboxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopSandboxResponse {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
    };
  },

  toJSON(message: StopSandboxResponse): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },

  create(base?: DeepPartial<StopSandboxResponse>): StopSandboxResponse {
    return StopSandboxResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopSandboxResponse>): StopSandboxResponse {
    const message = createBaseStopSandboxResponse();
    message.sandboxId = object.sandboxId ?? "";
    return message;
  },
};

function createBaseDestroySandboxRequest(): DestroySandboxRequest {
  return { sandboxId: "" };
}

export const DestroySandboxRequest: MessageFns<DestroySandboxRequest> = {
  encode(message: DestroySandboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DestroySandboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestroySandboxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestroySandboxRequest {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
    };
  },

  toJSON(message: DestroySandboxRequest): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },

  create(base?: DeepPartial<DestroySandboxRequest>): DestroySandboxRequest {
    return DestroySandboxRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DestroySandboxRequest>): DestroySandboxRequest {
    const message = createBaseDestroySandboxRequest();
    message.sandboxId = object.sandboxId ?? "";
    return message;
  },
};

function createBaseNodeToControl(): NodeToControl {
  return {
    heartbeat: undefined,
    execOutput: undefined,
    sessionOutput: undefined,
    execCompleted: undefined,
    sandboxEvent: undefined,
    artifactReport: undefined,
  };
}

export const NodeToControl: MessageFns<NodeToControl> = {
  encode(message: NodeToControl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.heartbeat !== undefined) {
      Heartbeat.encode(message.heartbeat, writer.uint32(10).fork()).join();
    }
    if (message.execOutput !== undefined) {
      ExecOutput.encode(message.execOutput, writer.uint32(18).fork()).join();
    }
    if (message.sessionOutput !== undefined) {
      SessionOutput.encode(message.sessionOutput, writer.uint32(26).fork()).join();
    }
    if (message.execCompleted !== undefined) {
      ExecCompleted.encode(message.execCompleted, writer.uint32(34).fork()).join();
    }
    if (message.sandboxEvent !== undefined) {
      SandboxEvent.encode(message.sandboxEvent, writer.uint32(42).fork()).join();
    }
    if (message.artifactReport !== undefined) {
      ArtifactReport.encode(message.artifactReport, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeToControl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeToControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.heartbeat = Heartbeat.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.execOutput = ExecOutput.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionOutput = SessionOutput.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.execCompleted = ExecCompleted.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sandboxEvent = SandboxEvent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.artifactReport = ArtifactReport.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeToControl {
    return {
      heartbeat: isSet(object.heartbeat) ? Heartbeat.fromJSON(object.heartbeat) : undefined,
      execOutput: isSet(object.execOutput)
        ? ExecOutput.fromJSON(object.execOutput)
        : isSet(object.exec_output)
        ? ExecOutput.fromJSON(object.exec_output)
        : undefined,
      sessionOutput: isSet(object.sessionOutput)
        ? SessionOutput.fromJSON(object.sessionOutput)
        : isSet(object.session_output)
        ? SessionOutput.fromJSON(object.session_output)
        : undefined,
      execCompleted: isSet(object.execCompleted)
        ? ExecCompleted.fromJSON(object.execCompleted)
        : isSet(object.exec_completed)
        ? ExecCompleted.fromJSON(object.exec_completed)
        : undefined,
      sandboxEvent: isSet(object.sandboxEvent)
        ? SandboxEvent.fromJSON(object.sandboxEvent)
        : isSet(object.sandbox_event)
        ? SandboxEvent.fromJSON(object.sandbox_event)
        : undefined,
      artifactReport: isSet(object.artifactReport)
        ? ArtifactReport.fromJSON(object.artifactReport)
        : isSet(object.artifact_report)
        ? ArtifactReport.fromJSON(object.artifact_report)
        : undefined,
    };
  },

  toJSON(message: NodeToControl): unknown {
    const obj: any = {};
    if (message.heartbeat !== undefined) {
      obj.heartbeat = Heartbeat.toJSON(message.heartbeat);
    }
    if (message.execOutput !== undefined) {
      obj.execOutput = ExecOutput.toJSON(message.execOutput);
    }
    if (message.sessionOutput !== undefined) {
      obj.sessionOutput = SessionOutput.toJSON(message.sessionOutput);
    }
    if (message.execCompleted !== undefined) {
      obj.execCompleted = ExecCompleted.toJSON(message.execCompleted);
    }
    if (message.sandboxEvent !== undefined) {
      obj.sandboxEvent = SandboxEvent.toJSON(message.sandboxEvent);
    }
    if (message.artifactReport !== undefined) {
      obj.artifactReport = ArtifactReport.toJSON(message.artifactReport);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeToControl>): NodeToControl {
    return NodeToControl.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeToControl>): NodeToControl {
    const message = createBaseNodeToControl();
    message.heartbeat = (object.heartbeat !== undefined && object.heartbeat !== null)
      ? Heartbeat.fromPartial(object.heartbeat)
      : undefined;
    message.execOutput = (object.execOutput !== undefined && object.execOutput !== null)
      ? ExecOutput.fromPartial(object.execOutput)
      : undefined;
    message.sessionOutput = (object.sessionOutput !== undefined && object.sessionOutput !== null)
      ? SessionOutput.fromPartial(object.sessionOutput)
      : undefined;
    message.execCompleted = (object.execCompleted !== undefined && object.execCompleted !== null)
      ? ExecCompleted.fromPartial(object.execCompleted)
      : undefined;
    message.sandboxEvent = (object.sandboxEvent !== undefined && object.sandboxEvent !== null)
      ? SandboxEvent.fromPartial(object.sandboxEvent)
      : undefined;
    message.artifactReport = (object.artifactReport !== undefined && object.artifactReport !== null)
      ? ArtifactReport.fromPartial(object.artifactReport)
      : undefined;
    return message;
  },
};

function createBaseControlToNode(): ControlToNode {
  return { noop: "" };
}

export const ControlToNode: MessageFns<ControlToNode> = {
  encode(message: ControlToNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.noop !== "") {
      writer.uint32(10).string(message.noop);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlToNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlToNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.noop = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlToNode {
    return { noop: isSet(object.noop) ? globalThis.String(object.noop) : "" };
  },

  toJSON(message: ControlToNode): unknown {
    const obj: any = {};
    if (message.noop !== "") {
      obj.noop = message.noop;
    }
    return obj;
  },

  create(base?: DeepPartial<ControlToNode>): ControlToNode {
    return ControlToNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ControlToNode>): ControlToNode {
    const message = createBaseControlToNode();
    message.noop = object.noop ?? "";
    return message;
  },
};

function createBaseHeartbeat(): Heartbeat {
  return { nodeId: "", activeSandboxIds: [], slotsTotal: 0, slotsUsed: 0, snapshotIds: [] };
}

export const Heartbeat: MessageFns<Heartbeat> = {
  encode(message: Heartbeat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    for (const v of message.activeSandboxIds) {
      writer.uint32(18).string(v!);
    }
    if (message.slotsTotal !== 0) {
      writer.uint32(24).uint32(message.slotsTotal);
    }
    if (message.slotsUsed !== 0) {
      writer.uint32(32).uint32(message.slotsUsed);
    }
    for (const v of message.snapshotIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Heartbeat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.activeSandboxIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.slotsTotal = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.slotsUsed = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.snapshotIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Heartbeat {
    return {
      nodeId: isSet(object.nodeId)
        ? globalThis.String(object.nodeId)
        : isSet(object.node_id)
        ? globalThis.String(object.node_id)
        : "",
      activeSandboxIds: globalThis.Array.isArray(object?.activeSandboxIds)
        ? object.activeSandboxIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.active_sandbox_ids)
        ? object.active_sandbox_ids.map((e: any) => globalThis.String(e))
        : [],
      slotsTotal: isSet(object.slotsTotal)
        ? globalThis.Number(object.slotsTotal)
        : isSet(object.slots_total)
        ? globalThis.Number(object.slots_total)
        : 0,
      slotsUsed: isSet(object.slotsUsed)
        ? globalThis.Number(object.slotsUsed)
        : isSet(object.slots_used)
        ? globalThis.Number(object.slots_used)
        : 0,
      snapshotIds: globalThis.Array.isArray(object?.snapshotIds)
        ? object.snapshotIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.snapshot_ids)
        ? object.snapshot_ids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Heartbeat): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.activeSandboxIds?.length) {
      obj.activeSandboxIds = message.activeSandboxIds;
    }
    if (message.slotsTotal !== 0) {
      obj.slotsTotal = Math.round(message.slotsTotal);
    }
    if (message.slotsUsed !== 0) {
      obj.slotsUsed = Math.round(message.slotsUsed);
    }
    if (message.snapshotIds?.length) {
      obj.snapshotIds = message.snapshotIds;
    }
    return obj;
  },

  create(base?: DeepPartial<Heartbeat>): Heartbeat {
    return Heartbeat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Heartbeat>): Heartbeat {
    const message = createBaseHeartbeat();
    message.nodeId = object.nodeId ?? "";
    message.activeSandboxIds = object.activeSandboxIds?.map((e) => e) || [];
    message.slotsTotal = object.slotsTotal ?? 0;
    message.slotsUsed = object.slotsUsed ?? 0;
    message.snapshotIds = object.snapshotIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseExecOutput(): ExecOutput {
  return { execId: "", seq: 0, stdout: undefined, stderr: undefined };
}

export const ExecOutput: MessageFns<ExecOutput> = {
  encode(message: ExecOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.seq !== 0) {
      writer.uint32(16).uint64(message.seq);
    }
    if (message.stdout !== undefined) {
      writer.uint32(26).bytes(message.stdout);
    }
    if (message.stderr !== undefined) {
      writer.uint32(34).bytes(message.stderr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.execId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.seq = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stdout = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stderr = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecOutput {
    return {
      execId: isSet(object.execId)
        ? globalThis.String(object.execId)
        : isSet(object.exec_id)
        ? globalThis.String(object.exec_id)
        : "",
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      stdout: isSet(object.stdout) ? Buffer.from(bytesFromBase64(object.stdout)) : undefined,
      stderr: isSet(object.stderr) ? Buffer.from(bytesFromBase64(object.stderr)) : undefined,
    };
  },

  toJSON(message: ExecOutput): unknown {
    const obj: any = {};
    if (message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.stdout !== undefined) {
      obj.stdout = base64FromBytes(message.stdout);
    }
    if (message.stderr !== undefined) {
      obj.stderr = base64FromBytes(message.stderr);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecOutput>): ExecOutput {
    return ExecOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecOutput>): ExecOutput {
    const message = createBaseExecOutput();
    message.execId = object.execId ?? "";
    message.seq = object.seq ?? 0;
    message.stdout = object.stdout ?? undefined;
    message.stderr = object.stderr ?? undefined;
    return message;
  },
};

function createBaseSessionOutput(): SessionOutput {
  return { sessionId: "", seq: 0, stdout: undefined, stderr: undefined };
}

export const SessionOutput: MessageFns<SessionOutput> = {
  encode(message: SessionOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.seq !== 0) {
      writer.uint32(16).uint64(message.seq);
    }
    if (message.stdout !== undefined) {
      writer.uint32(26).bytes(message.stdout);
    }
    if (message.stderr !== undefined) {
      writer.uint32(34).bytes(message.stderr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.seq = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stdout = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stderr = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionOutput {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      stdout: isSet(object.stdout) ? Buffer.from(bytesFromBase64(object.stdout)) : undefined,
      stderr: isSet(object.stderr) ? Buffer.from(bytesFromBase64(object.stderr)) : undefined,
    };
  },

  toJSON(message: SessionOutput): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.stdout !== undefined) {
      obj.stdout = base64FromBytes(message.stdout);
    }
    if (message.stderr !== undefined) {
      obj.stderr = base64FromBytes(message.stderr);
    }
    return obj;
  },

  create(base?: DeepPartial<SessionOutput>): SessionOutput {
    return SessionOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionOutput>): SessionOutput {
    const message = createBaseSessionOutput();
    message.sessionId = object.sessionId ?? "";
    message.seq = object.seq ?? 0;
    message.stdout = object.stdout ?? undefined;
    message.stderr = object.stderr ?? undefined;
    return message;
  },
};

function createBaseExecCompleted(): ExecCompleted {
  return { execId: "", exitCode: 0, cpuMs: 0, peakMemoryBytes: 0, durationMs: 0 };
}

export const ExecCompleted: MessageFns<ExecCompleted> = {
  encode(message: ExecCompleted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.exitCode !== 0) {
      writer.uint32(16).int32(message.exitCode);
    }
    if (message.cpuMs !== 0) {
      writer.uint32(24).uint64(message.cpuMs);
    }
    if (message.peakMemoryBytes !== 0) {
      writer.uint32(32).uint64(message.peakMemoryBytes);
    }
    if (message.durationMs !== 0) {
      writer.uint32(40).uint64(message.durationMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecCompleted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.execId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cpuMs = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.peakMemoryBytes = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.durationMs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecCompleted {
    return {
      execId: isSet(object.execId)
        ? globalThis.String(object.execId)
        : isSet(object.exec_id)
        ? globalThis.String(object.exec_id)
        : "",
      exitCode: isSet(object.exitCode)
        ? globalThis.Number(object.exitCode)
        : isSet(object.exit_code)
        ? globalThis.Number(object.exit_code)
        : 0,
      cpuMs: isSet(object.cpuMs)
        ? globalThis.Number(object.cpuMs)
        : isSet(object.cpu_ms)
        ? globalThis.Number(object.cpu_ms)
        : 0,
      peakMemoryBytes: isSet(object.peakMemoryBytes)
        ? globalThis.Number(object.peakMemoryBytes)
        : isSet(object.peak_memory_bytes)
        ? globalThis.Number(object.peak_memory_bytes)
        : 0,
      durationMs: isSet(object.durationMs)
        ? globalThis.Number(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.Number(object.duration_ms)
        : 0,
    };
  },

  toJSON(message: ExecCompleted): unknown {
    const obj: any = {};
    if (message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.cpuMs !== 0) {
      obj.cpuMs = Math.round(message.cpuMs);
    }
    if (message.peakMemoryBytes !== 0) {
      obj.peakMemoryBytes = Math.round(message.peakMemoryBytes);
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecCompleted>): ExecCompleted {
    return ExecCompleted.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecCompleted>): ExecCompleted {
    const message = createBaseExecCompleted();
    message.execId = object.execId ?? "";
    message.exitCode = object.exitCode ?? 0;
    message.cpuMs = object.cpuMs ?? 0;
    message.peakMemoryBytes = object.peakMemoryBytes ?? 0;
    message.durationMs = object.durationMs ?? 0;
    return message;
  },
};

function createBaseSandboxEvent(): SandboxEvent {
  return { sandboxId: "", eventType: 0, message: "" };
}

export const SandboxEvent: MessageFns<SandboxEvent> = {
  encode(message: SandboxEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).int32(message.eventType);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SandboxEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSandboxEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SandboxEvent {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
      eventType: isSet(object.eventType)
        ? sandboxEventTypeFromJSON(object.eventType)
        : isSet(object.event_type)
        ? sandboxEventTypeFromJSON(object.event_type)
        : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: SandboxEvent): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.eventType !== 0) {
      obj.eventType = sandboxEventTypeToJSON(message.eventType);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<SandboxEvent>): SandboxEvent {
    return SandboxEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SandboxEvent>): SandboxEvent {
    const message = createBaseSandboxEvent();
    message.sandboxId = object.sandboxId ?? "";
    message.eventType = object.eventType ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseArtifactReport(): ArtifactReport {
  return { sandboxId: "", artifacts: [] };
}

export const ArtifactReport: MessageFns<ArtifactReport> = {
  encode(message: ArtifactReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    for (const v of message.artifacts) {
      ReportedArtifact.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArtifactReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.artifacts.push(ReportedArtifact.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactReport {
    return {
      sandboxId: isSet(object.sandboxId)
        ? globalThis.String(object.sandboxId)
        : isSet(object.sandbox_id)
        ? globalThis.String(object.sandbox_id)
        : "",
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => ReportedArtifact.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ArtifactReport): unknown {
    const obj: any = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => ReportedArtifact.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ArtifactReport>): ArtifactReport {
    return ArtifactReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ArtifactReport>): ArtifactReport {
    const message = createBaseArtifactReport();
    message.sandboxId = object.sandboxId ?? "";
    message.artifacts = object.artifacts?.map((e) => ReportedArtifact.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReportedArtifact(): ReportedArtifact {
  return { name: "", mime: "", bytes: 0, sha256: "", ref: "" };
}

export const ReportedArtifact: MessageFns<ReportedArtifact> = {
  encode(message: ReportedArtifact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.mime !== "") {
      writer.uint32(18).string(message.mime);
    }
    if (message.bytes !== 0) {
      writer.uint32(24).uint64(message.bytes);
    }
    if (message.sha256 !== "") {
      writer.uint32(34).string(message.sha256);
    }
    if (message.ref !== "") {
      writer.uint32(42).string(message.ref);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportedArtifact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportedArtifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.bytes = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sha256 = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportedArtifact {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      mime: isSet(object.mime) ? globalThis.String(object.mime) : "",
      bytes: isSet(object.bytes) ? globalThis.Number(object.bytes) : 0,
      sha256: isSet(object.sha256) ? globalThis.String(object.sha256) : "",
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
    };
  },

  toJSON(message: ReportedArtifact): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.mime !== "") {
      obj.mime = message.mime;
    }
    if (message.bytes !== 0) {
      obj.bytes = Math.round(message.bytes);
    }
    if (message.sha256 !== "") {
      obj.sha256 = message.sha256;
    }
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    return obj;
  },

  create(base?: DeepPartial<ReportedArtifact>): ReportedArtifact {
    return ReportedArtifact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportedArtifact>): ReportedArtifact {
    const message = createBaseReportedArtifact();
    message.name = object.name ?? "";
    message.mime = object.mime ?? "";
    message.bytes = object.bytes ?? 0;
    message.sha256 = object.sha256 ?? "";
    message.ref = object.ref ?? "";
    return message;
  },
};

/**
 * Node service  hosted on the node daemon. The control plane connects to
 * each node's gRPC port to issue commands.
 */
export type NodeDefinition = typeof NodeDefinition;
export const NodeDefinition = {
  name: "Node",
  fullName: "sandchest.node.v1.Node",
  methods: {
    createSandbox: {
      name: "CreateSandbox",
      requestType: CreateSandboxRequest,
      requestStream: false,
      responseType: CreateSandboxResponse,
      responseStream: false,
      options: {},
    },
    createSandboxFromSnapshot: {
      name: "CreateSandboxFromSnapshot",
      requestType: CreateSandboxFromSnapshotRequest,
      requestStream: false,
      responseType: CreateSandboxResponse,
      responseStream: false,
      options: {},
    },
    forkSandbox: {
      name: "ForkSandbox",
      requestType: ForkSandboxRequest,
      requestStream: false,
      responseType: ForkSandboxResponse,
      responseStream: false,
      options: {},
    },
    exec: {
      name: "Exec",
      requestType: NodeExecRequest,
      requestStream: false,
      responseType: ExecEvent,
      responseStream: true,
      options: {},
    },
    createSession: {
      name: "CreateSession",
      requestType: NodeCreateSessionRequest,
      requestStream: false,
      responseType: NodeCreateSessionResponse,
      responseStream: false,
      options: {},
    },
    sessionExec: {
      name: "SessionExec",
      requestType: NodeSessionExecRequest,
      requestStream: false,
      responseType: ExecEvent,
      responseStream: true,
      options: {},
    },
    sessionInput: {
      name: "SessionInput",
      requestType: NodeSessionInputRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    destroySession: {
      name: "DestroySession",
      requestType: NodeDestroySessionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    putFile: {
      name: "PutFile",
      requestType: NodeFileChunk,
      requestStream: true,
      responseType: NodePutFileResponse,
      responseStream: false,
      options: {},
    },
    getFile: {
      name: "GetFile",
      requestType: NodeGetFileRequest,
      requestStream: false,
      responseType: NodeFileChunk,
      responseStream: true,
      options: {},
    },
    listFiles: {
      name: "ListFiles",
      requestType: NodeListFilesRequest,
      requestStream: false,
      responseType: NodeListFilesResponse,
      responseStream: false,
      options: {},
    },
    collectArtifacts: {
      name: "CollectArtifacts",
      requestType: CollectArtifactsRequest,
      requestStream: false,
      responseType: CollectArtifactsResponse,
      responseStream: false,
      options: {},
    },
    stopSandbox: {
      name: "StopSandbox",
      requestType: StopSandboxRequest,
      requestStream: false,
      responseType: StopSandboxResponse,
      responseStream: false,
      options: {},
    },
    destroySandbox: {
      name: "DestroySandbox",
      requestType: DestroySandboxRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

/**
 * Control service  hosted on the control plane. Node daemons connect and
 * open the StreamEvents bidirectional stream to send lifecycle events.
 */
export type ControlDefinition = typeof ControlDefinition;
export const ControlDefinition = {
  name: "Control",
  fullName: "sandchest.node.v1.Control",
  methods: {
    streamEvents: {
      name: "StreamEvents",
      requestType: NodeToControl,
      requestStream: true,
      responseType: ControlToNode,
      responseStream: true,
      options: {},
    },
  },
} as const;

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
